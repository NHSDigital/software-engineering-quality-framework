# Architect for flow

## Context

* These notes are part of a broader set of [principles](../principles.md)
* This pattern is closely related to the [deliver little and often](little-and-often.md) pattern

## The pattern

Technical design choices should primarily optimise for rapid, reliable delivery and operations, including:
* Small components are easier to work on and therefore quicker to change

## Benefits

* Cost efficient: teams don't waste their time fighting the tools
* Improves business agility: technologies and architectures which allow changes to be made rapidly and safely allow teams to respond more quickly to changes
* Improved reliability: it is easier to make easy-to-understand systems reliable, with fewer failures and shorter recovery times
* Improved recruitment and retention: engineers are happy when the tools they work with let them get on with what they do best
* Benefits of self-contained components:
    * The best tools can be chosen for each job (avoiding the "least worst" issues often found with monoliths)
    * Concerns such as scaling, resilience, etc, can be tailored on a per-component basis - for example avoiding the waste generated by scaling a monolith for the benefit of scaling one small aspect of the system
    * It is possible to isolate the impact of catastrophic component failure
    * Multiple components enable parallel development work
    * Teams can work at their own cadence
    * Self-contained components with clear boundaries of responsibility reduce hand-offs between teams
    * Components with clear boundaries of responsibility are more easily replaced
    * Components with clear boundaries of responsibility more likely to be reusable - note: this does not promote building "generic" components - rather, components that have a clear scope

## Details

* Split services vertically rather than horizontally: for example, do not implement dedicated processes to update databases or configuration

TO DO: more detail

## Caveats

* This pattern must not compromise quality: automation (including of quality control) is essential for safe implementation of this pattern
* Architectures with multiple moving parts are more complicated:
    * There is more to go wrong, and more failure points to test
    * Versioning becomes a more complicated concern
    * "Too many" components can cause more harm than good
    * Clean domain boundaries are essential for safe implementation of this pattern
    * Comprehensive monitoring and alerting is essential for safe implementation of this pattern

## Examples

TO DO
